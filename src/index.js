const { readFileSync, readdirSync, writeFileSync } = require("fs");
const mkdirp = require("mkdirp");
const { join } = require("path");

const go2dts = (srcFolder, outFolderOrFile) => {
  let output = "";
  const oneFile = /\.ts$/.test(outFolderOrFile);

  if (oneFile) {
    output += "/** \n";
    output += " * Generated by go2dts\n";
    output += " **/\n\n";
  }

  readdirSync(srcFolder)
    .filter(fileName => /^[a-z]+(?!test)\.go$/.test(fileName))
    .forEach(fileName => {
      const data = readFileSync(join(srcFolder, fileName), "utf-8");
      let isEmpty = true;

      if (!oneFile) {
        output = "/** \n";
        output += " * Generated by go2dts\n";
        output += " *\n";
        output += " * Source: " + fileName + "\n";
        output += " **/\n\n";
      }

      // Extract const
      const constRegex = /const \(([a-zA-Z\/ =,"\n\t\.()]*)\)/gm;
      let n;
      while ((n = constRegex.exec(data)) !== null) {
        output +=
          n[1]
            .split("\n")
            .filter(i => i.trim() !== "" && !i.startsWith("\t// "))
            .reduce((mem, line, i) => {
              const haveType = line.split(" =")[0].split(" ").length > 1;
              const type = line.split(" =")[0].split(" ")[1];
              const previousType = i > 0 ? mem[mem.length - 1].type : "";
              if (haveType && type !== previousType) {
                mem.push({
                  type,
                  values: [line.split(`"`)[1]]
                });
              } else {
                try {
                  mem[mem.length - 1].values.push(line.split(`"`)[1]);
                  isEmpty = false;
                } catch (e) {
                  // functional error if the first line `const` don't have any type
                  // we don't want to export this kind values for now
                  // (it's not an enum pattern)
                }
              }
              return mem;
            }, [])
            .map(i => `export type ${i.type} = "${i.values.join(`" | "`)}"`)
            .join("\n\n") + "\n\n";
      }

      // Extract struct
      const structRegex = /type\ (\w*)\ struct\ {([a-zA-Z .,-`":\n\t\[\]\*]*)}/gm;
      let m;
      while ((m = structRegex.exec(data)) !== null) {
        const name = m[1];
        const details = m[2]
          .split("\n")
          .filter(i => i.trim() !== "" && i.includes("json"))
          .map(parseParameter);

        if (details.length === 0) {
          continue;
        } else {
          isEmpty = false;
        }

        output += `export interface ${name} {`;
        output +=
          "\n" +
          details
            .filter(d => !d.internal)
            .map(d => `  ${d.name}${d.optional ? "?" : ""}: ${d.type}`)
            .join("\n");
        output += "\n}\n\n";
      }

      if (!oneFile && !isEmpty) {
        mkdirp.sync(outFolderOrFile);
        writeFileSync(
          join(outFolderOrFile, fileName.replace(".go", ".d.ts")),
          output
        );
      }
    });

  if (oneFile) {
    mkdirp.sync(join(outFolderOrFile, "../"));
    writeFileSync(outFolderOrFile, output);
  }
};

function parseParameter(i) {
  if (i.includes(`json:"-"`)) return { internal: true };

  try {
    const [, t, name] = /\t\w* *([a-zA-Z.*\[\]]+) *`json:"(\w+)/.exec(i);
    const goToTsMap = {
      "sql.JSONStringArray": "string[]",
      "sql.JSONStringMap": "{[key: string]: string}",
      "sql.JSONMap": "any",
      "null.Time": "Time | null",
      "time.Time": "Time",
      "uuid.UUID": "UUID",
      "null.UUID": "UUID | null",
      int: "number",
      bool: "boolean"
    };

    const optional = /\*/.test(t) || i.includes("omitempty");
    const isArray = /\[\]/.test(t);

    let type = t.replace(/[\[\]\*]/g, "") + (isArray ? "[]" : "");
    if (goToTsMap[type]) type = goToTsMap[type];
    return { type, name, optional };
  } catch (e) {
    console.log(`${i} can't be parsed`);
  }
}

module.exports = go2dts;
